// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.26.1
// source: gRPC.proto

package gRPC_proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MercenaryClient is the client API for Mercenary service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MercenaryClient interface {
	MercenaryReady(ctx context.Context, in *MercenaryReadyRequest, opts ...grpc.CallOption) (*MercenaryResponse, error)
	GetAccumulatedAmount(ctx context.Context, in *GetAccumulatedAmountRequest, opts ...grpc.CallOption) (*GetAccumulatedAmountResponse, error)
	GetFloor(ctx context.Context, in *MercenaryFloorRequest, opts ...grpc.CallOption) (*MercenaryFloorResponse, error)
}

type mercenaryClient struct {
	cc grpc.ClientConnInterface
}

func NewMercenaryClient(cc grpc.ClientConnInterface) MercenaryClient {
	return &mercenaryClient{cc}
}

func (c *mercenaryClient) MercenaryReady(ctx context.Context, in *MercenaryReadyRequest, opts ...grpc.CallOption) (*MercenaryResponse, error) {
	out := new(MercenaryResponse)
	err := c.cc.Invoke(ctx, "/grpc.Mercenary/MercenaryReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mercenaryClient) GetAccumulatedAmount(ctx context.Context, in *GetAccumulatedAmountRequest, opts ...grpc.CallOption) (*GetAccumulatedAmountResponse, error) {
	out := new(GetAccumulatedAmountResponse)
	err := c.cc.Invoke(ctx, "/grpc.Mercenary/GetAccumulatedAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mercenaryClient) GetFloor(ctx context.Context, in *MercenaryFloorRequest, opts ...grpc.CallOption) (*MercenaryFloorResponse, error) {
	out := new(MercenaryFloorResponse)
	err := c.cc.Invoke(ctx, "/grpc.Mercenary/GetFloor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MercenaryServer is the server API for Mercenary service.
// All implementations must embed UnimplementedMercenaryServer
// for forward compatibility
type MercenaryServer interface {
	MercenaryReady(context.Context, *MercenaryReadyRequest) (*MercenaryResponse, error)
	GetAccumulatedAmount(context.Context, *GetAccumulatedAmountRequest) (*GetAccumulatedAmountResponse, error)
	GetFloor(context.Context, *MercenaryFloorRequest) (*MercenaryFloorResponse, error)
	mustEmbedUnimplementedMercenaryServer()
}

// UnimplementedMercenaryServer must be embedded to have forward compatible implementations.
type UnimplementedMercenaryServer struct {
}

func (UnimplementedMercenaryServer) MercenaryReady(context.Context, *MercenaryReadyRequest) (*MercenaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MercenaryReady not implemented")
}
func (UnimplementedMercenaryServer) GetAccumulatedAmount(context.Context, *GetAccumulatedAmountRequest) (*GetAccumulatedAmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccumulatedAmount not implemented")
}
func (UnimplementedMercenaryServer) GetFloor(context.Context, *MercenaryFloorRequest) (*MercenaryFloorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFloor not implemented")
}
func (UnimplementedMercenaryServer) mustEmbedUnimplementedMercenaryServer() {}

// UnsafeMercenaryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MercenaryServer will
// result in compilation errors.
type UnsafeMercenaryServer interface {
	mustEmbedUnimplementedMercenaryServer()
}

func RegisterMercenaryServer(s grpc.ServiceRegistrar, srv MercenaryServer) {
	s.RegisterService(&Mercenary_ServiceDesc, srv)
}

func _Mercenary_MercenaryReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MercenaryReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MercenaryServer).MercenaryReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Mercenary/MercenaryReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MercenaryServer).MercenaryReady(ctx, req.(*MercenaryReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mercenary_GetAccumulatedAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccumulatedAmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MercenaryServer).GetAccumulatedAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Mercenary/GetAccumulatedAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MercenaryServer).GetAccumulatedAmount(ctx, req.(*GetAccumulatedAmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mercenary_GetFloor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MercenaryFloorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MercenaryServer).GetFloor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Mercenary/GetFloor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MercenaryServer).GetFloor(ctx, req.(*MercenaryFloorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Mercenary_ServiceDesc is the grpc.ServiceDesc for Mercenary service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mercenary_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.Mercenary",
	HandlerType: (*MercenaryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MercenaryReady",
			Handler:    _Mercenary_MercenaryReady_Handler,
		},
		{
			MethodName: "GetAccumulatedAmount",
			Handler:    _Mercenary_GetAccumulatedAmount_Handler,
		},
		{
			MethodName: "GetFloor",
			Handler:    _Mercenary_GetFloor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gRPC.proto",
}

// DirectorClient is the client API for Director service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DirectorClient interface {
	MercenaryDecision(ctx context.Context, in *MercenaryDecisionRequest, opts ...grpc.CallOption) (*MercenaryDecisionResponse, error)
	GetAccumulatedAmount(ctx context.Context, in *GetAccumulatedAmountRequest, opts ...grpc.CallOption) (*GetAccumulatedAmountResponse, error)
}

type directorClient struct {
	cc grpc.ClientConnInterface
}

func NewDirectorClient(cc grpc.ClientConnInterface) DirectorClient {
	return &directorClient{cc}
}

func (c *directorClient) MercenaryDecision(ctx context.Context, in *MercenaryDecisionRequest, opts ...grpc.CallOption) (*MercenaryDecisionResponse, error) {
	out := new(MercenaryDecisionResponse)
	err := c.cc.Invoke(ctx, "/grpc.Director/MercenaryDecision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directorClient) GetAccumulatedAmount(ctx context.Context, in *GetAccumulatedAmountRequest, opts ...grpc.CallOption) (*GetAccumulatedAmountResponse, error) {
	out := new(GetAccumulatedAmountResponse)
	err := c.cc.Invoke(ctx, "/grpc.Director/GetAccumulatedAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DirectorServer is the server API for Director service.
// All implementations must embed UnimplementedDirectorServer
// for forward compatibility
type DirectorServer interface {
	MercenaryDecision(context.Context, *MercenaryDecisionRequest) (*MercenaryDecisionResponse, error)
	GetAccumulatedAmount(context.Context, *GetAccumulatedAmountRequest) (*GetAccumulatedAmountResponse, error)
	mustEmbedUnimplementedDirectorServer()
}

// UnimplementedDirectorServer must be embedded to have forward compatible implementations.
type UnimplementedDirectorServer struct {
}

func (UnimplementedDirectorServer) MercenaryDecision(context.Context, *MercenaryDecisionRequest) (*MercenaryDecisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MercenaryDecision not implemented")
}
func (UnimplementedDirectorServer) GetAccumulatedAmount(context.Context, *GetAccumulatedAmountRequest) (*GetAccumulatedAmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccumulatedAmount not implemented")
}
func (UnimplementedDirectorServer) mustEmbedUnimplementedDirectorServer() {}

// UnsafeDirectorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DirectorServer will
// result in compilation errors.
type UnsafeDirectorServer interface {
	mustEmbedUnimplementedDirectorServer()
}

func RegisterDirectorServer(s grpc.ServiceRegistrar, srv DirectorServer) {
	s.RegisterService(&Director_ServiceDesc, srv)
}

func _Director_MercenaryDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MercenaryDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectorServer).MercenaryDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Director/MercenaryDecision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectorServer).MercenaryDecision(ctx, req.(*MercenaryDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Director_GetAccumulatedAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccumulatedAmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectorServer).GetAccumulatedAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Director/GetAccumulatedAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectorServer).GetAccumulatedAmount(ctx, req.(*GetAccumulatedAmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Director_ServiceDesc is the grpc.ServiceDesc for Director service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Director_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.Director",
	HandlerType: (*DirectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MercenaryDecision",
			Handler:    _Director_MercenaryDecision_Handler,
		},
		{
			MethodName: "GetAccumulatedAmount",
			Handler:    _Director_GetAccumulatedAmount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gRPC.proto",
}

// NamenodeClient is the client API for Namenode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NamenodeClient interface {
	RegisterDecision(ctx context.Context, in *RegisterDecisionRequest, opts ...grpc.CallOption) (*RegisterDecisionResponse, error)
	GetRegisteredDecisions(ctx context.Context, in *GetRegisteredDecisionsRequest, opts ...grpc.CallOption) (*GetRegisteredDecisionsResponse, error)
}

type namenodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNamenodeClient(cc grpc.ClientConnInterface) NamenodeClient {
	return &namenodeClient{cc}
}

func (c *namenodeClient) RegisterDecision(ctx context.Context, in *RegisterDecisionRequest, opts ...grpc.CallOption) (*RegisterDecisionResponse, error) {
	out := new(RegisterDecisionResponse)
	err := c.cc.Invoke(ctx, "/grpc.Namenode/RegisterDecision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namenodeClient) GetRegisteredDecisions(ctx context.Context, in *GetRegisteredDecisionsRequest, opts ...grpc.CallOption) (*GetRegisteredDecisionsResponse, error) {
	out := new(GetRegisteredDecisionsResponse)
	err := c.cc.Invoke(ctx, "/grpc.Namenode/GetRegisteredDecisions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NamenodeServer is the server API for Namenode service.
// All implementations must embed UnimplementedNamenodeServer
// for forward compatibility
type NamenodeServer interface {
	RegisterDecision(context.Context, *RegisterDecisionRequest) (*RegisterDecisionResponse, error)
	GetRegisteredDecisions(context.Context, *GetRegisteredDecisionsRequest) (*GetRegisteredDecisionsResponse, error)
	mustEmbedUnimplementedNamenodeServer()
}

// UnimplementedNamenodeServer must be embedded to have forward compatible implementations.
type UnimplementedNamenodeServer struct {
}

func (UnimplementedNamenodeServer) RegisterDecision(context.Context, *RegisterDecisionRequest) (*RegisterDecisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDecision not implemented")
}
func (UnimplementedNamenodeServer) GetRegisteredDecisions(context.Context, *GetRegisteredDecisionsRequest) (*GetRegisteredDecisionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisteredDecisions not implemented")
}
func (UnimplementedNamenodeServer) mustEmbedUnimplementedNamenodeServer() {}

// UnsafeNamenodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NamenodeServer will
// result in compilation errors.
type UnsafeNamenodeServer interface {
	mustEmbedUnimplementedNamenodeServer()
}

func RegisterNamenodeServer(s grpc.ServiceRegistrar, srv NamenodeServer) {
	s.RegisterService(&Namenode_ServiceDesc, srv)
}

func _Namenode_RegisterDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamenodeServer).RegisterDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Namenode/RegisterDecision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamenodeServer).RegisterDecision(ctx, req.(*RegisterDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Namenode_GetRegisteredDecisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegisteredDecisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamenodeServer).GetRegisteredDecisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Namenode/GetRegisteredDecisions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamenodeServer).GetRegisteredDecisions(ctx, req.(*GetRegisteredDecisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Namenode_ServiceDesc is the grpc.ServiceDesc for Namenode service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Namenode_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.Namenode",
	HandlerType: (*NamenodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDecision",
			Handler:    _Namenode_RegisterDecision_Handler,
		},
		{
			MethodName: "GetRegisteredDecisions",
			Handler:    _Namenode_GetRegisteredDecisions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gRPC.proto",
}

// DoshbankClient is the client API for Doshbank service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DoshbankClient interface {
	GetAccumulatedAmount(ctx context.Context, in *GetAccumulatedAmountRequest, opts ...grpc.CallOption) (*GetAccumulatedAmountResponse, error)
}

type doshbankClient struct {
	cc grpc.ClientConnInterface
}

func NewDoshbankClient(cc grpc.ClientConnInterface) DoshbankClient {
	return &doshbankClient{cc}
}

func (c *doshbankClient) GetAccumulatedAmount(ctx context.Context, in *GetAccumulatedAmountRequest, opts ...grpc.CallOption) (*GetAccumulatedAmountResponse, error) {
	out := new(GetAccumulatedAmountResponse)
	err := c.cc.Invoke(ctx, "/grpc.Doshbank/GetAccumulatedAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DoshbankServer is the server API for Doshbank service.
// All implementations must embed UnimplementedDoshbankServer
// for forward compatibility
type DoshbankServer interface {
	GetAccumulatedAmount(context.Context, *GetAccumulatedAmountRequest) (*GetAccumulatedAmountResponse, error)
	mustEmbedUnimplementedDoshbankServer()
}

// UnimplementedDoshbankServer must be embedded to have forward compatible implementations.
type UnimplementedDoshbankServer struct {
}

func (UnimplementedDoshbankServer) GetAccumulatedAmount(context.Context, *GetAccumulatedAmountRequest) (*GetAccumulatedAmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccumulatedAmount not implemented")
}
func (UnimplementedDoshbankServer) mustEmbedUnimplementedDoshbankServer() {}

// UnsafeDoshbankServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DoshbankServer will
// result in compilation errors.
type UnsafeDoshbankServer interface {
	mustEmbedUnimplementedDoshbankServer()
}

func RegisterDoshbankServer(s grpc.ServiceRegistrar, srv DoshbankServer) {
	s.RegisterService(&Doshbank_ServiceDesc, srv)
}

func _Doshbank_GetAccumulatedAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccumulatedAmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DoshbankServer).GetAccumulatedAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Doshbank/GetAccumulatedAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DoshbankServer).GetAccumulatedAmount(ctx, req.(*GetAccumulatedAmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Doshbank_ServiceDesc is the grpc.ServiceDesc for Doshbank service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Doshbank_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.Doshbank",
	HandlerType: (*DoshbankServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccumulatedAmount",
			Handler:    _Doshbank_GetAccumulatedAmount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gRPC.proto",
}

// DatanodeClient is the client API for Datanode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DatanodeClient interface {
	GetFileContent(ctx context.Context, in *GetFileContentRequest, opts ...grpc.CallOption) (*GetFileContentResponse, error)
}

type datanodeClient struct {
	cc grpc.ClientConnInterface
}

func NewDatanodeClient(cc grpc.ClientConnInterface) DatanodeClient {
	return &datanodeClient{cc}
}

func (c *datanodeClient) GetFileContent(ctx context.Context, in *GetFileContentRequest, opts ...grpc.CallOption) (*GetFileContentResponse, error) {
	out := new(GetFileContentResponse)
	err := c.cc.Invoke(ctx, "/grpc.Datanode/GetFileContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DatanodeServer is the server API for Datanode service.
// All implementations must embed UnimplementedDatanodeServer
// for forward compatibility
type DatanodeServer interface {
	GetFileContent(context.Context, *GetFileContentRequest) (*GetFileContentResponse, error)
	mustEmbedUnimplementedDatanodeServer()
}

// UnimplementedDatanodeServer must be embedded to have forward compatible implementations.
type UnimplementedDatanodeServer struct {
}

func (UnimplementedDatanodeServer) GetFileContent(context.Context, *GetFileContentRequest) (*GetFileContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileContent not implemented")
}
func (UnimplementedDatanodeServer) mustEmbedUnimplementedDatanodeServer() {}

// UnsafeDatanodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DatanodeServer will
// result in compilation errors.
type UnsafeDatanodeServer interface {
	mustEmbedUnimplementedDatanodeServer()
}

func RegisterDatanodeServer(s grpc.ServiceRegistrar, srv DatanodeServer) {
	s.RegisterService(&Datanode_ServiceDesc, srv)
}

func _Datanode_GetFileContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatanodeServer).GetFileContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.Datanode/GetFileContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatanodeServer).GetFileContent(ctx, req.(*GetFileContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Datanode_ServiceDesc is the grpc.ServiceDesc for Datanode service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Datanode_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.Datanode",
	HandlerType: (*DatanodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFileContent",
			Handler:    _Datanode_GetFileContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gRPC.proto",
}
